"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GitHubConfigGenerator = void 0;
const yaml_1 = __importDefault(require("yaml"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const BuildDockerImage_1 = __importDefault(require("../../SemanticModel/Tasks/BuildDockerImage"));
const Checkout_1 = __importDefault(require("../../SemanticModel/Tasks/Checkout"));
const tasks_1 = require("./tasks");
const PullDockerImage_1 = __importDefault(require("../../SemanticModel/Tasks/PullDockerImage"));
const Run_1 = __importDefault(require("../../SemanticModel/Tasks/Run"));
class GitHubConfigGenerator {
    constructor(pipeline) {
        this.generateConfig = () => {
            if (!this.shouldGenerate())
                return;
            // Generate Folders and files
            this.createFolderStructure();
            this.buildSecrets();
            this.buildTriggers();
            this.buildStages();
            this.writeToFile();
        };
        this.writeToFile = () => {
            fs_1.default.writeFileSync(path_1.default.join(process.cwd(), ".github/workflows/workflow.yml"), yaml_1.default.stringify(this.configObject), "utf-8");
        };
        this.createFolderStructure = () => {
            if (fs_1.default.existsSync(path_1.default.join(process.cwd(), ".github"))) {
                fs_1.default.rmSync(path_1.default.join(process.cwd(), ".github"), { recursive: true });
            }
            fs_1.default.mkdirSync(path_1.default.join(process.cwd(), ".github"));
            fs_1.default.mkdirSync(path_1.default.join(process.cwd(), ".github/workflows"));
            fs_1.default.writeFileSync(path_1.default.join(process.cwd(), ".github/workflows/workflow.yml"), "", "utf-8");
        };
        this.buildTriggers = () => {
            const isPushSet = this.pipeline.getTrigger().getTypes().includes('push');
            const isPullRequestSet = this.pipeline.getTrigger().getTypes().includes('pull_request');
            const onObject = {};
            const triggerObject = {
                on: onObject
            };
            if (isPushSet) {
                const pushObject = {
                    branches: [...this.pipeline.getTrigger().getBranches()]
                };
                triggerObject.on.push = pushObject;
            }
            if (isPullRequestSet) {
                const pullRequestObject = {
                    branches: [...this.pipeline.getTrigger().getBranches()]
                };
                triggerObject.on.pull_request = pullRequestObject;
            }
            Object.assign(this.configObject, triggerObject);
        };
        this.buildSecrets = () => {
            this.pipeline = this.changeSecretsSyntax(this.pipeline);
        };
        this.changeSecretsSyntax = (obj) => {
            if (typeof obj === 'object') {
                // iterating over the object using for..in
                for (let key in obj) {
                    //checking if the current value is an object itself
                    if (typeof obj[key] === 'object') {
                        // if so then again calling the same function
                        this.changeSecretsSyntax(obj[key]);
                    }
                    else {
                        // else getting the value and replacing single { with {{ and so on
                        if (obj[key] !== undefined) {
                            const secrets = obj[key].match(/\$\{(secrets\.)[a-zA-Z][^{}]+\}/gm);
                            if (secrets) {
                                for (let i = 0; i < secrets.length; i++) {
                                    let newValue = obj[key].replace(secrets[i], "${{ " + secrets[i].replace("${", "").replace("}", "") + " }}");
                                    obj[key] = newValue;
                                }
                            }
                        }
                    }
                }
            }
            return obj;
        };
        this.buildStages = () => {
            const StagesArray = {};
            const stagesObject = {
                jobs: StagesArray
            };
            for (let stage of this.pipeline.getStages()) {
                const builtStage = this.buildStage(stage);
                const stageId = this.generateStageId(this.sanitizeJobName(stage.getName()));
                stagesObject.jobs[stageId] = builtStage;
            }
            Object.assign(this.configObject, stagesObject);
        };
        this.generateStageId = (name) => {
            const str = "" + name;
            return str.replace(' ', '_').toLowerCase();
        };
        this.buildStage = (stage) => {
            const stageObject = {
                steps: this.buildJobs(stage.getJobs())
            };
            Object.assign(stageObject, this.setRuntimeContainer(stage));
            if (stage.getNeeds().length > 0) {
                stageObject.needs = stage.getNeeds();
            }
            ;
            return stageObject;
        };
        this.buildJobs = (jobs) => {
            const resultArr = [];
            for (let job of jobs) {
                const tasks = job.getTasks();
                for (let task of tasks) {
                    resultArr.push(this.buildTask(task));
                }
            }
            return resultArr;
        };
        this.setRuntimeContainer = (stage) => {
            const runsOn = stage.getRunsOn();
            if (runsOn != "ubuntu-latest" && runsOn != "windows-latest") {
                return { 'runs-on': "ubuntu-latest", 'container': runsOn };
            }
            return { 'runs-on': runsOn };
        };
        this.sanitizeJobName = (name) => {
            return name.replaceAll(' ', '_');
        };
        this.buildTask = (task) => {
            if (task instanceof BuildDockerImage_1.default) {
                return (0, tasks_1.generateBuildDockerImageTask)(task);
            }
            if (task instanceof Checkout_1.default) {
                return (0, tasks_1.generateCheckoutTask)(task);
            }
            if (task instanceof PullDockerImage_1.default) {
                return (0, tasks_1.generatePullDockerImageTask)(task);
            }
            if (task instanceof Run_1.default) {
                return (0, tasks_1.generateRunTask)(task);
            }
        };
        this.pipeline = pipeline;
        this.configObject = {};
    }
    shouldGenerate() {
        return this.pipeline != undefined && this.pipeline.getPlatformTargets().getTargets().includes('GitHub');
    }
}
exports.GitHubConfigGenerator = GitHubConfigGenerator;
//# sourceMappingURL=index.js.map