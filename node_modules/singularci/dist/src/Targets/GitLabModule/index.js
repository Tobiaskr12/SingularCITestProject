"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GitLabConfigGenerator = void 0;
const yaml_1 = __importDefault(require("yaml"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const BuildDockerImage_1 = __importDefault(require("../../SemanticModel/Tasks/BuildDockerImage"));
const Checkout_1 = __importDefault(require("../../SemanticModel/Tasks/Checkout"));
const PullDockerImage_1 = __importDefault(require("../../SemanticModel/Tasks/PullDockerImage"));
const Run_1 = __importDefault(require("../../SemanticModel/Tasks/Run"));
const tasks_1 = require("./tasks");
class GitLabConfigGenerator {
    constructor(pipeline) {
        this.generateConfig = () => {
            if (!this.shouldGenerate())
                return;
            this.buildSecrets();
            this.buildTriggers();
            this.buildStages();
            this.buildJobs();
            this.writeToFile();
        };
        this.writeToFile = () => {
            fs_1.default.writeFileSync(path_1.default.join(process.cwd(), ".gitlab-ci.yml"), yaml_1.default.stringify(this.configObject), "utf-8");
        };
        this.changeSecretsSyntax = (obj) => {
            if (typeof obj === 'object') {
                // iterating over the object using for..in
                for (var key in obj) {
                    //checking if the current value is an object itself
                    if (typeof obj[key] === 'object') {
                        // if so then again calling the same function
                        this.changeSecretsSyntax(obj[key]);
                    }
                    else {
                        // else getting the value and replacing single { with {{ and so on
                        if (obj[key] !== undefined) {
                            const secrets = obj[key].match(/\$\{(secrets\.)[a-zA-Z][^{}]+\}/gm);
                            if (secrets) {
                                for (let i = 0; i < secrets.length; i++) {
                                    let newValue = obj[key].replace(secrets[i], "$" + secrets[i].replace("${secrets.", "").replace("}", "") + "");
                                    obj[key] = newValue;
                                }
                            }
                        }
                    }
                }
            }
            return obj;
        };
        this.buildNeeds = (needs) => {
            const needsArray = [];
            for (let k = 0; k < needs.length; k++) {
                const needsName = needs[k];
                const neededStage = this.pipeline.getStages().find(stage => stage.getName() === needsName);
                if (neededStage) {
                    const jobs = neededStage.getJobs();
                    const jobAmount = jobs.length;
                    for (let l = 0; l < jobAmount; l++) {
                        const jobName = `${neededStage.getName()}-${this.sanitizeJobName(jobs[l].getName())}`;
                        needsArray.push(jobName);
                    }
                }
            }
            return needsArray;
        };
        this.buildTasks = (stageKey, jobObject, tasks) => {
            const tasksArray = [];
            for (let task of tasks) {
                if (task instanceof BuildDockerImage_1.default) {
                    jobObject[stageKey].services = (0, tasks_1.dockerSetup)();
                    tasksArray.push(...(0, tasks_1.generateBuildDockerImageTask)(task));
                }
                if (task instanceof Checkout_1.default) {
                    console.log("Checkout should not be specified on GitLab");
                }
                if (task instanceof PullDockerImage_1.default) {
                    tasksArray.push(...(0, tasks_1.generatePullDockerImageTask)(task));
                }
                if (task instanceof Run_1.default) {
                    tasksArray.push(...(0, tasks_1.generateRunTask)(task));
                }
            }
            return tasksArray;
        };
        this.sanitizeJobName = (name) => {
            return name.replaceAll(' ', '_');
        };
        this.pipeline = pipeline;
        this.configObject = {};
    }
    shouldGenerate() {
        return this.pipeline != undefined && this.pipeline.getPlatformTargets().getTargets().includes('GitLab');
    }
    buildStages() {
        const stagesArray = [];
        for (let i = 0; i < this.pipeline.getStages().length; i++) {
            const stage = this.pipeline.getStages()[i];
            stagesArray.push(stage.getName());
        }
        this.configObject.stages = stagesArray;
    }
    buildTriggers() {
        const isPushSet = this.pipeline.getTrigger().getTypes().includes('push');
        const isPullRequestSet = this.pipeline.getTrigger().getTypes().includes('pull_request');
        const rulesObject = [];
        const triggerObject = {
            workflow: {
                rules: rulesObject
            }
        };
        if (isPushSet) {
            triggerObject.workflow.rules.push({
                if: '$CI_PIPELINE_SOURCE == "push"',
                when: 'always'
            });
        }
        if (isPullRequestSet) {
            triggerObject.workflow.rules.push({
                if: '$CI_PIPELINE_SOURCE == "merge_request_event"',
                when: 'always'
            });
        }
        Object.assign(this.configObject, triggerObject);
    }
    buildSecrets() {
        this.pipeline = this.changeSecretsSyntax(this.pipeline);
    }
    buildJobs() {
        const stages = this.pipeline.getStages();
        for (let i = 0; i < stages.length; i++) {
            const jobs = stages[i].getJobs();
            for (let j = 0; j < jobs.length; j++) {
                const tasks = jobs[j].getTasks();
                const needs = stages[i].getNeeds();
                const beforeTasks = [];
                const stage = stages[i];
                const stageKey = `${stage.getName()}-${this.sanitizeJobName(jobs[j].getName())}`;
                let tasksArray = [];
                let needsArray = [];
                needsArray = this.buildNeeds(needs);
                const jobObject = {
                    [stageKey]: {
                        image: this.getSelectedImage(this.pipeline.getStages()[i]),
                        stage: this.pipeline.getStages()[i].getName(),
                        script: tasksArray,
                        needs: needsArray
                    }
                };
                tasksArray = this.buildTasks(stageKey, jobObject, tasks);
                Object.assign(this.configObject, jobObject);
            }
        }
    }
    getSelectedImage(stage) {
        return stage.getRunsOn();
    }
}
exports.GitLabConfigGenerator = GitLabConfigGenerator;
//# sourceMappingURL=index.js.map