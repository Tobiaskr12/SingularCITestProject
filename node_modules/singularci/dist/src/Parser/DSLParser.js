"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const yaml_1 = __importDefault(require("yaml"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const StageSymbolTable_1 = __importDefault(require("./StageSymbolTable"));
const StageBuilder_1 = __importDefault(require("./StageBuilder"));
const Run_1 = __importDefault(require("../SemanticModel/Tasks/Run"));
const BuildDockerImage_1 = __importDefault(require("./../SemanticModel/Tasks/BuildDockerImage"));
const Job_1 = __importDefault(require("../Common/Job"));
const Stage_1 = __importDefault(require("../Common/Stage"));
const Pipeline_1 = __importDefault(require("../Common/Pipeline"));
const Targets_1 = __importDefault(require("./../SemanticModel/Targets"));
const Variables_1 = __importDefault(require("./../SemanticModel/Variables"));
const Trigger_1 = __importDefault(require("../SemanticModel/Trigger"));
const typedi_1 = require("typedi");
const JobBuilderFactory_1 = require("./JobBuilderFactory");
const PullDockerImage_1 = __importDefault(require("../SemanticModel/Tasks/PullDockerImage"));
const Checkout_1 = __importDefault(require("../SemanticModel/Tasks/Checkout"));
let DSLParser = class DSLParser {
    constructor(inputFileName, pipeline, jobBuilderFactory) {
        let inputFilePath = path_1.default.join(process.cwd(), inputFileName);
        let fileCloneName = '.singularci-copy.yml';
        this.fileClonePath = path_1.default.join(process.cwd(), fileCloneName);
        fs_1.default.copyFileSync(inputFilePath, this.fileClonePath);
        this.inputFileClone = fs_1.default.readFileSync(this.fileClonePath, 'utf8');
        this.pipeline = pipeline;
        this.jobBuilderFactory = jobBuilderFactory;
    }
    parse() {
        const variables = this.buildVariables();
        this.resolveVariables(variables);
        const targets = this.buildTargets();
        const triggers = this.buildTriggers();
        const stages = this.buildStages();
        ;
        this.buildSymbolTable(stages);
        return this.buildPipeline(targets, variables, triggers);
    }
    resolveVariables(variables) {
        for (let variable in variables.getVariables()) {
            this.inputFileClone = this.inputFileClone.replaceAll("${" + variable + "}", variables.getVariable(variable));
        }
        // The regex tests if there are any undeclared variables in the file, which are not platform specific secrets
        let undefinedVariables = this.inputFileClone.match(/\$\{(?!secrets\.)[a-zA-Z][^{}]+\}/gm);
        if (undefinedVariables != null) {
            throw new Error(`Error: The following variable(s) are used, but not declared: ${undefinedVariables}`);
        }
    }
    buildTargets() {
        try {
            const targetsArray = yaml_1.default.parse(this.inputFileClone)['pipeline']['targets'];
            const targets = new Targets_1.default();
            for (let target of targetsArray) {
                targets.addTarget(target);
            }
            return targets;
        }
        catch (error) {
            throw new Error(error.message);
        }
    }
    buildTriggers() {
        try {
            const triggersArray = yaml_1.default.parse(this.inputFileClone)['pipeline']['triggers'];
            const triggers = new Trigger_1.default();
            for (let triggerTypes of triggersArray.trigger_types) {
                triggers.addType(triggerTypes);
            }
            for (let triggerBranch of triggersArray.branches) {
                triggers.addBranch(triggerBranch);
            }
            return triggers;
        }
        catch (error) {
            throw new Error(error.message);
        }
    }
    buildVariables() {
        try {
            const variablesArray = yaml_1.default.parse(this.inputFileClone)['pipeline']['variables'];
            const variables = new Variables_1.default();
            for (let variable of variablesArray) {
                variables.addVariable(variable.key, variable.value);
            }
            return variables;
        }
        catch (error) {
            throw new Error(error.message);
        }
    }
    buildStages() {
        try {
            const stages = yaml_1.default.parse(this.inputFileClone)['pipeline']['stages'];
            const stageList = [];
            for (let stageObject of stages) {
                stageList.push(this.buildStage(stageObject.stage));
            }
            return stageList;
        }
        catch (error) {
            throw new Error(error.message);
        }
    }
    buildSymbolTable(stages) {
        const stageSymbolTable = StageSymbolTable_1.default.getInstance();
        stageSymbolTable.reset();
        for (let stage of stages) {
            stageSymbolTable.addStage(stage);
        }
    }
    buildStage(stage) {
        const stageBuilder = new StageBuilder_1.default();
        try {
            if (stage.name && stage.runs_on && stage.jobs) {
                stageBuilder.setName(stage.name);
                stageBuilder.setRunsOn(stage.runs_on);
                this.addNeedsToStage(stage, stageBuilder);
                this.buildJobs(stage, stageBuilder);
            }
            else {
                throw new Error(`Stage is missing a name or runs_on property`);
            }
        }
        catch (error) {
            console.error(error.message);
        }
        return stageBuilder;
    }
    addNeedsToStage(stage, stageBuilder) {
        if (stage.needs) {
            for (let need of stage.needs) {
                stageBuilder.addNeeds(need);
            }
        }
    }
    buildJobs(stage, stageBuilder) {
        for (let job of stage.jobs) {
            const jobBuilder = this.jobBuilderFactory.createJobBuilder();
            jobBuilder.setName(job.name);
            this.addTasksToJob(job, jobBuilder);
            stageBuilder.addJob(new Job_1.default(jobBuilder.getName(), jobBuilder.getTasks()));
        }
    }
    addTasksToJob(job, jobBuilder) {
        if (job.run) {
            jobBuilder.addTask(this.createRunTask(job.run));
        }
        if (job.docker_build) {
            jobBuilder.addTask(this.createDockerBuildTask(job.docker_build));
        }
        if (job.docker_pull) {
            jobBuilder.addTask(this.createDockerPullTask(job.docker_pull));
        }
        if (job.checkout) {
            jobBuilder.addTask(this.createCheckoutTask(job.checkout));
        }
    }
    createRunTask(command) {
        const run = new Run_1.default(command);
        return run;
    }
    createDockerBuildTask(job) {
        const docker_build = new BuildDockerImage_1.default(job.image_name, job.docker_file_path, job.user_name, job.password);
        return docker_build;
    }
    createDockerPullTask(job) {
        const docker_pull = new PullDockerImage_1.default(job.image_name, job.user_name, job.password);
        return docker_pull;
    }
    createCheckoutTask(repo_url) {
        const checkout = new Checkout_1.default(repo_url);
        return checkout;
    }
    buildPipeline(targets, variables, trigger) {
        const stageSymbolTable = StageSymbolTable_1.default.getInstance();
        this.pipeline.reset();
        for (let stage in stageSymbolTable.getStages()) {
            const stageBuilder = stageSymbolTable.getStage(stage);
            const finalStage = new Stage_1.default(stageBuilder.getName(), stageBuilder.getJobs(), stageBuilder.getNeeds(), stageBuilder.getRunsOn());
            this.pipeline.addStage(finalStage);
        }
        this.pipeline.setPlatformTargets(targets);
        this.pipeline.setVariables(variables);
        this.pipeline.setTrigger(trigger);
        return this.pipeline;
    }
};
DSLParser = __decorate([
    (0, typedi_1.Service)({ id: 'dslparser' }),
    __param(0, (0, typedi_1.Inject)('dslparser.inputFileName')),
    __param(1, (0, typedi_1.Inject)('Pipeline')),
    __param(2, (0, typedi_1.Inject)('JobBuilderFactory')),
    __metadata("design:paramtypes", [String, Pipeline_1.default,
        JobBuilderFactory_1.JobBuilderFactory])
], DSLParser);
exports.default = DSLParser;
//# sourceMappingURL=DSLParser.js.map